---
title: "20241107_linear_models"
output: github_document
date: "2024-11-07"
---

```{r setup, include=FALSE}
library(tidyverse)
library(p8105.datasets)

set.seed(1)

```

In airbnb dataset, see how different rental prices differ

Doing some data cleaning first

```{r}
data("nyc_airbnb")

nyc_airbnb = 
  nyc_airbnb %>%  
  mutate(stars = review_scores_location / 2) %>%  
  rename(
    borough = neighbourhood_group,
    neighborhood = neighbourhood) %>%  
  filter(borough != "Staten Island") %>%  
  select(price, stars, borough, neighborhood, room_type) %>% 
  mutate(
    borough = fct_infreq(borough),
    room_type = fct_infreq(room_type)
  )
```

## Fit some models 

consider price as an outcome that may depend on rating We fit that initial model in the following code.

```{r}
fit = lm(price ~ stars, data = nyc_airbnb)

```

Giving us:
Coefficients:
(Intercept)        stars  
     -66.50        44.11  
     
other things that we can ask 

```{r}
fit = lm(price ~ stars, data = nyc_airbnb)

summary(fit)

names(summary(fit))

coef(fit)

broom::tidy(fit) #tidys up the summary into a tibble, easily interpret. since tibble can tidy it 

fit %>% 
  broom::tidy() %>% 
  select(term, estimate, p.value)

fit %>% 
  broom::glance()
```

Try a bit more complex 

```{r}
fit = 
  lm(price ~ stars + borough, data = nyc_airbnb)
```

borough broken up into one reference category (the bronx) and three remaining boroughs are compared to the bronx (ordered based alphabetical)

```{r}
fit = 
  lm(price ~ stars + borough, data = nyc_airbnb)

fit %>% 
  broom::tidy() %>% 
  select(term, estimate, p.value) %>% 
  mutate(
    term = str_replace(term, "borough", "Borough: ")
  ) %>% 
  knitr::kable(digits = 3)

```

But then change with new order of the nyc_airbnb data we factored/ reordering the borough based on frequency, so Manhatten became reference 

But still can compare Brooklyn and Queens by just comparing the two intercepts. Nothign inherently changes, just the reference 

## Some Diagnostics

```{r}
nyc_airbnb %>% 
  ggplot(aes(x = stars, y = price)) + 
  geom_point() +
  stat_smooth(method = "lm")
```

Does the stars go up as the price goes up?
Looking at this plot this is about right (but there are extreme outliers; residuals)


Regression diagnostics can identify issues in model fit, especially related to certain failures in model assumptions. Examining residuals and fitted values are therefore an imporant component of any modeling exercise.

Most diagnostics use residuals 

```{r}
modelr::add_residuals(nyc_airbnb, fit)
```

Now have a dataframe and can do dataframe things to it 


```{r}
modelr::add_residuals(nyc_airbnb, fit) %>% 
  ggplot(aes(x = resid)) +
  geom_histogram()
```


```{r}
modelr::add_residuals(nyc_airbnb, fit) %>% 
  ggplot(aes(x = borough, y = resid)) +
  geom_violin() + 
  ylim(-200, 200)
```

See that residuals are relatively skewed and the residual distribution different across different boroughs 

This gives us an understanding of how our model regression is fitting our data. Whether there is bias, fitting one borough better than another etc. 

Residuals against star ratings 

```{r}
modelr::add_residuals(nyc_airbnb, fit) %>% # in this line of code, use modelr fit this dataframe and use fit to add residuals
  ggplot(aes(x = stars, y = resid)) +
  geom_point() 
```


Can compare residuals against fitted values

```{r}
nyc_airbnb %>% 
  modelr::add_residuals(fit) %>% 
  modelr::add_predictions(fit) %>% 
  ggplot(aes(x = pred, y = resid)) + 
  geom_point()
```


